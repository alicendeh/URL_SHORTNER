{"ast":null,"code":"import React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nconst canvasStyle = {\n  position: 'absolute',\n  bottom: 0,\n  left: 0,\n  height: 0,\n  overflow: 'hidden',\n  'padding-top': 0,\n  'padding-bottom': 0,\n  border: 'none'\n};\nconst mirrorProps = ['box-sizing', 'width', 'font-size', 'font-weight', 'font-family', 'font-style', 'letter-spacing', 'text-indent', 'white-space', 'word-break', 'overflow-wrap', 'padding-left', 'padding-right'];\n\nfunction omit(obj, omittedKeys) {\n  if (!obj || typeof obj !== 'object') {\n    return obj;\n  }\n\n  const ret = {};\n  Object.keys(obj).forEach(key => {\n    if (omittedKeys.indexOf(key) > -1) {\n      return;\n    }\n\n    ret[key] = obj[key];\n  });\n  return ret;\n}\n\nfunction prevSibling(node, count) {\n  while (node && count--) {\n    node = node.previousElementSibling;\n  }\n\n  return node;\n}\n\nconst defaultProps = {\n  basedOn: undefined,\n  className: '',\n  component: 'div',\n  ellipsis: '…',\n  // &hellip;\n  maxLine: 1,\n\n  onReflow() {},\n\n  text: '',\n  trimRight: true,\n  winWidth: undefined // for the HOC\n\n};\nconst usedProps = Object.keys(defaultProps);\n/**\n * props.text {String} the text you want to clamp\n * props.maxLine {Number|String} max lines allowed\n * props.ellipsis {String} the ellipsis indicator\n * props.trimRight {Boolean} should we trimRight the clamped text?\n * props.basedOn {String} letters|words\n * props.className {String}\n */\n\nclass LinesEllipsis extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      text: props.text,\n      clamped: false\n    };\n    this.units = [];\n    this.maxLine = 0;\n    this.canvas = null;\n  }\n\n  componentDidMount() {\n    this.initCanvas();\n    this.reflow(this.props);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.winWidth !== this.props.winWidth) {\n      this.copyStyleToCanvas();\n    }\n\n    if (this.props !== prevProps) {\n      this.reflow(this.props);\n    }\n  }\n\n  componentWillUnmount() {\n    this.canvas.parentNode.removeChild(this.canvas);\n  }\n\n  setState(state, callback) {\n    if (typeof state.clamped !== 'undefined') {\n      this.clamped = state.clamped;\n    }\n\n    return super.setState(state, callback);\n  }\n\n  initCanvas() {\n    if (this.canvas) return;\n    const canvas = this.canvas = document.createElement('div');\n    canvas.className = `LinesEllipsis-canvas ${this.props.className}`;\n    canvas.setAttribute('aria-hidden', 'true');\n    this.copyStyleToCanvas();\n    Object.keys(canvasStyle).forEach(key => {\n      canvas.style[key] = canvasStyle[key];\n    });\n    document.body.appendChild(canvas);\n  }\n\n  copyStyleToCanvas() {\n    const targetStyle = window.getComputedStyle(this.target);\n    mirrorProps.forEach(key => {\n      this.canvas.style[key] = targetStyle[key];\n    });\n  }\n\n  reflow(props) {\n    /* eslint-disable no-control-regex */\n    const basedOn = props.basedOn || (/^[\\x00-\\x7F]+$/.test(props.text) ? 'words' : 'letters');\n\n    switch (basedOn) {\n      case 'words':\n        this.units = props.text.split(/\\b|(?=\\W)/);\n        break;\n\n      case 'letters':\n        this.units = Array.from(props.text);\n        break;\n\n      default:\n        throw new Error(`Unsupported options basedOn: ${basedOn}`);\n    }\n\n    this.maxLine = +props.maxLine || 1;\n    this.canvas.innerHTML = this.units.map(c => {\n      return `<span class='LinesEllipsis-unit'>${c}</span>`;\n    }).join('');\n    const ellipsisIndex = this.putEllipsis(this.calcIndexes());\n    const clamped = ellipsisIndex > -1;\n    const newState = {\n      clamped,\n      text: clamped ? this.units.slice(0, ellipsisIndex).join('') : props.text\n    };\n    this.setState(newState, props.onReflow.bind(this, newState));\n  }\n\n  calcIndexes() {\n    const indexes = [0];\n    let elt = this.canvas.firstElementChild;\n    if (!elt) return indexes;\n    let index = 0;\n    let line = 1;\n    let offsetTop = elt.offsetTop;\n\n    while (elt = elt.nextElementSibling) {\n      if (elt.offsetTop > offsetTop) {\n        line++;\n        indexes.push(index);\n        offsetTop = elt.offsetTop;\n      }\n\n      index++;\n\n      if (line > this.maxLine) {\n        break;\n      }\n    }\n\n    return indexes;\n  }\n\n  putEllipsis(indexes) {\n    if (indexes.length <= this.maxLine) return -1;\n    const lastIndex = indexes[this.maxLine];\n    const units = this.units.slice(0, lastIndex);\n    const maxOffsetTop = this.canvas.children[lastIndex].offsetTop;\n    this.canvas.innerHTML = units.map((c, i) => {\n      return `<span class='LinesEllipsis-unit'>${c}</span>`;\n    }).join('') + `<wbr><span class='LinesEllipsis-ellipsis'>${this.props.ellipsis}</span>`;\n    const ndEllipsis = this.canvas.lastElementChild;\n    let ndPrevUnit = prevSibling(ndEllipsis, 2);\n\n    while (ndPrevUnit && (ndEllipsis.offsetTop > maxOffsetTop || // IE & Edge: doesn't support <wbr>\n    ndEllipsis.offsetHeight > ndPrevUnit.offsetHeight || ndEllipsis.offsetTop > ndPrevUnit.offsetTop)) {\n      this.canvas.removeChild(ndPrevUnit);\n      ndPrevUnit = prevSibling(ndEllipsis, 2);\n      units.pop();\n    }\n\n    return units.length;\n  } // expose\n\n\n  isClamped() {\n    return this.clamped; // do not use state.clamped. #27\n  }\n\n  render() {\n    const {\n      text,\n      clamped\n    } = this.state;\n\n    const _this$props = this.props,\n          {\n      component: Component,\n      ellipsis,\n      trimRight,\n      className\n    } = _this$props,\n          rest = _objectWithoutPropertiesLoose(_this$props, [\"component\", \"ellipsis\", \"trimRight\", \"className\"]);\n\n    return /*#__PURE__*/React.createElement(Component, _extends({\n      className: `LinesEllipsis ${clamped ? 'LinesEllipsis--clamped' : ''} ${className}`,\n      ref: node => this.target = node\n    }, omit(rest, usedProps)), clamped && trimRight ? text.replace(/[\\s\\uFEFF\\xA0]+$/, '') : text, /*#__PURE__*/React.createElement(\"wbr\", null), clamped && /*#__PURE__*/React.createElement(\"span\", {\n      className: \"LinesEllipsis-ellipsis\"\n    }, ellipsis));\n  }\n\n}\n\nLinesEllipsis.defaultProps = defaultProps;\nexport default LinesEllipsis;","map":{"version":3,"sources":["/home/alice/Desktop/Reactjs clone/shortly/node_modules/react-lines-ellipsis/lib/index.modern.js"],"names":["React","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","canvasStyle","position","bottom","left","height","overflow","border","mirrorProps","omit","obj","omittedKeys","ret","forEach","prevSibling","node","count","previousElementSibling","defaultProps","basedOn","undefined","className","component","ellipsis","maxLine","onReflow","text","trimRight","winWidth","usedProps","LinesEllipsis","Component","constructor","props","state","clamped","units","canvas","componentDidMount","initCanvas","reflow","componentDidUpdate","prevProps","copyStyleToCanvas","componentWillUnmount","parentNode","removeChild","setState","callback","document","createElement","setAttribute","style","body","appendChild","targetStyle","window","getComputedStyle","test","split","Array","from","Error","innerHTML","map","c","join","ellipsisIndex","putEllipsis","calcIndexes","newState","slice","bind","indexes","elt","firstElementChild","index","line","offsetTop","nextElementSibling","push","lastIndex","maxOffsetTop","children","ndEllipsis","lastElementChild","ndPrevUnit","offsetHeight","pop","isClamped","render","_this$props","rest","ref","replace"],"mappings":"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","sourcesContent":["import React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nconst canvasStyle = {\n  position: 'absolute',\n  bottom: 0,\n  left: 0,\n  height: 0,\n  overflow: 'hidden',\n  'padding-top': 0,\n  'padding-bottom': 0,\n  border: 'none'\n};\nconst mirrorProps = ['box-sizing', 'width', 'font-size', 'font-weight', 'font-family', 'font-style', 'letter-spacing', 'text-indent', 'white-space', 'word-break', 'overflow-wrap', 'padding-left', 'padding-right'];\n\nfunction omit(obj, omittedKeys) {\n  if (!obj || typeof obj !== 'object') {\n    return obj;\n  }\n\n  const ret = {};\n  Object.keys(obj).forEach(key => {\n    if (omittedKeys.indexOf(key) > -1) {\n      return;\n    }\n\n    ret[key] = obj[key];\n  });\n  return ret;\n}\n\nfunction prevSibling(node, count) {\n  while (node && count--) {\n    node = node.previousElementSibling;\n  }\n\n  return node;\n}\n\nconst defaultProps = {\n  basedOn: undefined,\n  className: '',\n  component: 'div',\n  ellipsis: '…',\n  // &hellip;\n  maxLine: 1,\n\n  onReflow() {},\n\n  text: '',\n  trimRight: true,\n  winWidth: undefined // for the HOC\n\n};\nconst usedProps = Object.keys(defaultProps);\n/**\n * props.text {String} the text you want to clamp\n * props.maxLine {Number|String} max lines allowed\n * props.ellipsis {String} the ellipsis indicator\n * props.trimRight {Boolean} should we trimRight the clamped text?\n * props.basedOn {String} letters|words\n * props.className {String}\n */\n\nclass LinesEllipsis extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      text: props.text,\n      clamped: false\n    };\n    this.units = [];\n    this.maxLine = 0;\n    this.canvas = null;\n  }\n\n  componentDidMount() {\n    this.initCanvas();\n    this.reflow(this.props);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.winWidth !== this.props.winWidth) {\n      this.copyStyleToCanvas();\n    }\n\n    if (this.props !== prevProps) {\n      this.reflow(this.props);\n    }\n  }\n\n  componentWillUnmount() {\n    this.canvas.parentNode.removeChild(this.canvas);\n  }\n\n  setState(state, callback) {\n    if (typeof state.clamped !== 'undefined') {\n      this.clamped = state.clamped;\n    }\n\n    return super.setState(state, callback);\n  }\n\n  initCanvas() {\n    if (this.canvas) return;\n    const canvas = this.canvas = document.createElement('div');\n    canvas.className = `LinesEllipsis-canvas ${this.props.className}`;\n    canvas.setAttribute('aria-hidden', 'true');\n    this.copyStyleToCanvas();\n    Object.keys(canvasStyle).forEach(key => {\n      canvas.style[key] = canvasStyle[key];\n    });\n    document.body.appendChild(canvas);\n  }\n\n  copyStyleToCanvas() {\n    const targetStyle = window.getComputedStyle(this.target);\n    mirrorProps.forEach(key => {\n      this.canvas.style[key] = targetStyle[key];\n    });\n  }\n\n  reflow(props) {\n    /* eslint-disable no-control-regex */\n    const basedOn = props.basedOn || (/^[\\x00-\\x7F]+$/.test(props.text) ? 'words' : 'letters');\n\n    switch (basedOn) {\n      case 'words':\n        this.units = props.text.split(/\\b|(?=\\W)/);\n        break;\n\n      case 'letters':\n        this.units = Array.from(props.text);\n        break;\n\n      default:\n        throw new Error(`Unsupported options basedOn: ${basedOn}`);\n    }\n\n    this.maxLine = +props.maxLine || 1;\n    this.canvas.innerHTML = this.units.map(c => {\n      return `<span class='LinesEllipsis-unit'>${c}</span>`;\n    }).join('');\n    const ellipsisIndex = this.putEllipsis(this.calcIndexes());\n    const clamped = ellipsisIndex > -1;\n    const newState = {\n      clamped,\n      text: clamped ? this.units.slice(0, ellipsisIndex).join('') : props.text\n    };\n    this.setState(newState, props.onReflow.bind(this, newState));\n  }\n\n  calcIndexes() {\n    const indexes = [0];\n    let elt = this.canvas.firstElementChild;\n    if (!elt) return indexes;\n    let index = 0;\n    let line = 1;\n    let offsetTop = elt.offsetTop;\n\n    while (elt = elt.nextElementSibling) {\n      if (elt.offsetTop > offsetTop) {\n        line++;\n        indexes.push(index);\n        offsetTop = elt.offsetTop;\n      }\n\n      index++;\n\n      if (line > this.maxLine) {\n        break;\n      }\n    }\n\n    return indexes;\n  }\n\n  putEllipsis(indexes) {\n    if (indexes.length <= this.maxLine) return -1;\n    const lastIndex = indexes[this.maxLine];\n    const units = this.units.slice(0, lastIndex);\n    const maxOffsetTop = this.canvas.children[lastIndex].offsetTop;\n    this.canvas.innerHTML = units.map((c, i) => {\n      return `<span class='LinesEllipsis-unit'>${c}</span>`;\n    }).join('') + `<wbr><span class='LinesEllipsis-ellipsis'>${this.props.ellipsis}</span>`;\n    const ndEllipsis = this.canvas.lastElementChild;\n    let ndPrevUnit = prevSibling(ndEllipsis, 2);\n\n    while (ndPrevUnit && (ndEllipsis.offsetTop > maxOffsetTop || // IE & Edge: doesn't support <wbr>\n    ndEllipsis.offsetHeight > ndPrevUnit.offsetHeight || ndEllipsis.offsetTop > ndPrevUnit.offsetTop)) {\n      this.canvas.removeChild(ndPrevUnit);\n      ndPrevUnit = prevSibling(ndEllipsis, 2);\n      units.pop();\n    }\n\n    return units.length;\n  } // expose\n\n\n  isClamped() {\n    return this.clamped; // do not use state.clamped. #27\n  }\n\n  render() {\n    const {\n      text,\n      clamped\n    } = this.state;\n\n    const _this$props = this.props,\n          {\n      component: Component,\n      ellipsis,\n      trimRight,\n      className\n    } = _this$props,\n          rest = _objectWithoutPropertiesLoose(_this$props, [\"component\", \"ellipsis\", \"trimRight\", \"className\"]);\n\n    return /*#__PURE__*/React.createElement(Component, _extends({\n      className: `LinesEllipsis ${clamped ? 'LinesEllipsis--clamped' : ''} ${className}`,\n      ref: node => this.target = node\n    }, omit(rest, usedProps)), clamped && trimRight ? text.replace(/[\\s\\uFEFF\\xA0]+$/, '') : text, /*#__PURE__*/React.createElement(\"wbr\", null), clamped && /*#__PURE__*/React.createElement(\"span\", {\n      className: \"LinesEllipsis-ellipsis\"\n    }, ellipsis));\n  }\n\n}\n\nLinesEllipsis.defaultProps = defaultProps;\n\nexport default LinesEllipsis;\n"]},"metadata":{},"sourceType":"module"}